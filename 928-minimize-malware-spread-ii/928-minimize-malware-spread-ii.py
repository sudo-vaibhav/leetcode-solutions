class Solution:
    
    ## Quick Union Find
	## Data Structure for quickly getting connected components of a graph
    ## Guarantees log(n) time to get_component_id, join, is_connected, get_size
    class UnionFind:
        
        def __init__(self, size):
            self.size = size
            self.id = [i for i in range(size)]
            self.component_size = [1 for i in range(size)]
        
        ## get the component id 
        def get_component_id(self,node_id):
            curr_id = node_id
            while (self.id[node_id] != node_id):
                node_id = self.id[node_id] 
            end = node_id
                
            ## flatten this structure (not necessary, just an optimization)
            curr_id = node_id
            while (self.id[node_id] != node_id):
                next_node = self.id[node_id] 
                self.id[node_id] = end
            return end
        
        ## are p and q in the same component?
        def is_connected(self,p,q):
            return self.get_component_id(p) == self.get_component_id(q)
        
        ## combined the two components p and q are in
        def join(self, p, q):
            root_p = self.get_component_id(p)
            root_q = self.get_component_id(q)
            
            if self.component_size[root_p] < self.component_size[root_q]:
                self.join(root_q,root_p)
                return
            
            if not self.is_connected(root_p,root_q):
            
                self.id[root_q] = root_p
                self.component_size[root_p] += self.component_size[root_q]
        
        ## what is the size of the component p is in?
        def get_size(self,p):
            return self.component_size[self.get_component_id(p)]
        
    
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        initial_set = set(initial)
        
        ## create connected components of non-malware nodes
        uf = Solution.UnionFind(n)
        for i in range(n):
            if i not in initial_set:
                for j in range(n):
                    if graph[i][j] and j not in initial_set:
                        uf.join(i,j)
        
        ## for each component, get a set of all malware nodes that connect directly to it
        components_to_malware = defaultdict(set)
        for i in initial_set:
            for j in range(n):
                if graph[i][j] == 1 and j not in initial_set:
                    components_to_malware[uf.get_component_id(j)].add(i)
        
        ## for each component if it is connected to:
        ##      0 malware nodes, then they will never be infected, no matter what is removed
        ##      1 malware node,  then they will not be infected if that node is removed, otherwise they will be
        ##      2 malware nodes, they will always be infected, no matter what is removed
        ## So go through every component, if it connected to only one malware node, add the components size
        ## to malware_size, which is a dictionary with keys the malware ids and values M(initial) if the id
        ## is removed.
        malware_size = defaultdict(int)
        # for i in initial_set:
        #     malware_size[i] = 0
        for component in components_to_malware.keys():
            if len(components_to_malware[component]) == 1:
                for malware_id in components_to_malware[component]:
                    malware_size[malware_id] += uf.get_size(component)
        
        ## go through all malware_ids, select the id with greatest size (and smallest id if there is a tie)
        best_id = min(initial)
        best_size = -1
        for malware_id in malware_size.keys():
            if malware_size[malware_id] > best_size or (malware_size[malware_id] == best_size and malware_id < best_id):
                best_size = malware_size[malware_id]
                best_id = malware_id
        return best_id
# class Solution:
#     def minMalwareSpread(self, adjMat: List[List[int]], initial: List[int]) -> int:
#         class UF:
#             def __init__(self,n):
#                 self.parent = list(range(n))
#                 self.size = [1]*n
            
#             def union(self,u,v):
#                 pu,pv = self.find(u),self.find(v)
#                 if pu==pv:  
#                     return False
#                 else:
#                     smaller = pu if self.get_size(pu)<self.get_size(pv) else pu
#                     larger = pu if pu!=smaller else pv
#                     self.parent[smaller]=larger
#                     self.size[larger]+=self.size[smaller]
#                     return True
            
#             def get_size(self,node):
#                 return self.size[self.find(node)]
            
#             def find(self,v):
#                 if self.parent[v]==v:
#                     return v
#                 else:
#                     self.parent[v] = self.find(self.parent[v])
#                     return self.parent[v]
        
#         N = len(adjMat)
#         uf = UF(N)
#         initial.sort()
#         initial_set = set(initial)
#         clean = [i for i in range(N) if i not in initial_set]
        
#         for i in clean:
#             for j in clean:
#                 if adjMat[i][j]:
#                     uf.union(i,j)
#                     uf.find(i)
#                     uf.find(j)
#         infecToComps = defaultdict(set)
#         parentInteractsWithInfected = defaultdict(int)
        
#         for infec in initial:
#             for node in clean:
#                 if adjMat[infec][node]:
#                     parent = uf.find(node)
#                     infecToComps[infec].add(parent)
#                     parentInteractsWithInfected[parent]+=1
        
#         ansNode,ansVal = None,-1
        
#         for infec in initial:
#             tempans = 0
#             for neighComp in infecToComps[infec]:
#                 if parentInteractsWithInfected[neighComp]==1:
# #                     only then will infec's removal will be able to help 
#                     tempans += uf.get_size(neighComp)
    
#             if (tempans>ansVal):
#                 ansNode,ansVal = infec,tempans
#         return ansNode
            
        
                
# # class DSU:
# #     def __init__(self, N):
# #         self.p = list(range(N))
# #         self.sz = [1] * N

# #     def find(self, x):
# #         if self.p[x] != x:
# #             self.p[x] = self.find(self.p[x])
# #         return self.p[x]

# #     def union(self, x, y):
# #         xr = self.find(x)
# #         yr = self.find(y)
# #         self.p[xr] = yr
# #         self.sz[yr] += self.sz[xr]

# #     def size(self, x):
# #         return self.sz[self.find(x)]


# # class Solution(object):
# #     def minMalwareSpread(self, graph, initial):
# #         N = len(graph)
# #         initial_set = set(initial)
# #         clean = [x for x in range(N) if x not in initial_set]

# #         # clean[u] == 1 if its a node in the graph not in initial.
# #         dsu = DSU(N)
# #         for u in clean:
# #             for v in clean:
# #                 if graph[u][v]:
# #                     dsu.union(u, v)

# #         # dsu now represents the components of the graph without
# #         # any nodes from initial.  Let's call this graph G.
# #         count = collections.Counter()
# #         node_to_compo = {}
# #         for u in initial:
# #             components = set()
# #             for v in clean:
# #                 if graph[u][v]:
# #                     components.add(dsu.find(v))
# #             node_to_compo[u] = components

# #             for c in components:
# #                 count[c] += 1

# #         # For each node u in initial, nodeToCompo.get(u)
# #         # now has every component from G that u neighbors.

# #         best = (-1, None) # score, node
# #         for u in node_to_compo:
# #             components = node_to_compo[u]
# #             score = 0
# #             for c in components:
# #                 if count[c] == 1: #uniquely infected
# #                     score += dsu.size(c)
# #             if score > best[0] or score == best[0] and u < best[1]:
# #                 best = (score, u)

# #         return best[1]